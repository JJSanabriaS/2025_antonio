
# =========================================
# STEP 1 ‚Äî INSTALL DEPENDENCIES
# =========================================
!apt-get update -qq
!apt-get install -qq chromium-chromedriver
!pip install -q selenium tabulate ipywidgets pillow pandas requests

# =========================================
# STEP 2 ‚Äî IMPORTS
# =========================================
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from IPython.display import display, clear_output
import ipywidgets as widgets
import requests
import pandas as pd

# =========================================
# STEP 3 ‚Äî SELENIUM SETUP
# =========================================
chrome_options = Options()
chrome_options.add_argument("--headless")
chrome_options.add_argument("--no-sandbox")
chrome_options.add_argument("--disable-dev-shm-usage")
chrome_options.add_argument("--window-size=1920,1080")


driver = webdriver.Chrome(options=chrome_options)
wait = WebDriverWait(driver, timeout=10)
driver.set_window_size(1920, 1080)  # Full HD size
# =========================================
# STEP 4 ‚Äî SCRAPER FUNCTION
# =========================================
def prinp():
    url = "https://opcoes.net.br/opcoes/bovespa/AMBP3"
    driver.get(url)
    vencimentos = driver.find_element(By.ID, "grade-vencimentos-dates")
    # Use WebDriverWait to wait for the checkbox to be clickable
    # Changed the locator to be more specific if possible, targeting the checkbox within the vencimentos element
    checkbox = wait.until(EC.presence_of_element_located((By.XPATH, "//div[@id='grade-vencimentos-dates']//input[@type='checkbox']")))
    #print("grade tipo")
    #print(vencimentos.text)
    ids = driver.find_elements(By.TAG_NAME,"input")
    vencimentos=[]
    datas=[]
    data_du=[]
    mix=[]
    for ii in ids:
        #print ii.tag_name
        #print (ii.get_attribute('id'))    # id name as string
        datas.append(ii.get_attribute('id'))
        data_du.append(ii.get_attribute('data-du'))
        #print("label    ",ii.get_attribute('label'))
        #print("value   ",ii.get_attribute('value'))
        #print("data-du   ",ii.get_attribute('data-du'))
        vencimentos.append(ii.get_attribute('selected'))
        mix.append(str(ii.get_attribute('id'))+"  - "+str(ii.get_attribute('data-du'))+" "+" d.u.")
        #print(str(ii.get_attribute('id'))+"  - "+str(ii.get_attribute('data-du'))+" "+" d.u.")


        #if id_val :
        #    datas.append(id_val)
    #print(f"‚úÖ Found {len(datas)} vencimentos.")
    box=len(datas)-5
    #print(datas[0:3])
    #print(vencimentos[0:3])
   # print("labels  ", datas[3:box])
    datas2=datas[3:box]
    datas=mix[3:box]
    #print(datas)
    #print (data_du[3:box]+"d.u.")
    return datas,datas2

[datas,datas2]= prinp()

# =========================================
# STEP 5 ‚Äî MULTISELECT + SMART TOGGLE SYNC
# =========================================

# Create list of (label, value) pairs
options = list(zip(datas, datas2))
options_dict = dict(zip(datas2, datas))

# Define the multi-select widget
multi_vencimentos = widgets.SelectMultiple(
    options=options,
    description='Vencimentos:',
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='60%', height='220px')
)

display(multi_vencimentos)

# Keep track of previously selected options
previous_selection = set()

def on_change(change):
    global previous_selection
    if change['type'] == 'change' and change['name'] == 'value':
        clear_output(wait=True)
        display(multi_vencimentos)

        current_selection = set(change['new'])
        newly_selected = current_selection - previous_selection
        deselected = previous_selection - current_selection
        previous_selection = current_selection

        print("üîπ Current selection:")
        for val in current_selection:
            print(f"   {options_dict[val]} ‚Üí id={val}")

        # Scroll to checkbox area
        driver.execute_script("window.scrollBy(0, 300);")

        # Handle newly selected options
        for val in newly_selected:
            try:
                checkbox = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.ID, val))
                )
                if not checkbox.is_selected():
                    driver.execute_script("arguments[0].click();", checkbox)
                print(f"‚úÖ Checked {options_dict[val]}")
            except Exception as e:
                print(f"‚ö†Ô∏è Could not check {val}: {e}")

        # Handle deselected options
        for val in deselected:
            try:
                checkbox = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.ID, val))
                )
                if checkbox.is_selected():
                    driver.execute_script("arguments[0].click();", checkbox)
                print(f"‚ùé Unchecked {options_dict[val]}")
            except Exception as e:
                print(f"‚ö†Ô∏è Could not uncheck {val}: {e}")

        # Optional: Screenshot
        try:
            driver.save_screenshot("/content/checkbox_sync.png")
            print("üì∏ Screenshot saved as /content/checkbox_sync.png")
        except Exception as e:
            print(f"‚ö†Ô∏è Screenshot error: {e}")

multi_vencimentos.observe(on_change)


