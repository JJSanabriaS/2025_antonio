create a user interface for using on jupyter notebook with three buttons first one for populating multi select input called "vencimentos" (getting values from get_vencimentos funxtiion) and dropdown input called "ativos" (adding option "todo" as first one, values obtained from option_texts), where the another two buttons should be invisible until polulating is finished, the second button should xlear any xhexkbox setted on webpage, open selexted ativo webpage, xhexk the boxes page axxording to selected venximentos options, update webpage and get data from updated webpage and one final button to download just one copy of the obtained data (resumo and top30) the logic is on code below # ========================================= # STEP 1 ‚Äî INSTALL DEPENDENCIES # ========================================= !apt-get update -qq !apt-get install -qq chromium-chromedriver !pip install -q selenium tabulate ipywidgets pillow pandas requests # ============================================ # C√ìDIGO APRIMORADO (vers√£o completa, a partir de #c√≥digo 22) # ============================================ # ========================================= # STEP 2 ‚Äî IMPORTS # ========================================= %pip install -q selenium tabulate pandas from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait, Select from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.chrome.options import Options from selenium.common.exceptions import StaleElementReferenceException, TimeoutException from PIL import Image from google.colab import files, drive import pandas as pd import requests import time from tabulate import tabulate from datetime import datetime from IPython.display import display, clear_output import ipywidgets as widgets # ---------------------------------------------------------- # CONFIGURA√á√ÉO DO DRIVER (modo headless) # ---------------------------------------------------------- chrome_options = Options() chrome_options.add_argument("--headless") chrome_options.add_argument("--no-sandbox") chrome_options.add_argument("--disable-dev-shm-usage") chrome_options.add_argument("--window-size=1920,1080") driver = webdriver.Chrome(options=chrome_options) wait = WebDriverWait(driver, 15) driver.set_window_size(1920, 1080) return driver, wait # ---------------------------------------------------------- # FUN√á√ïES AUXILIARES # ---------------------------------------------------------- # ========================================= # STEP 4 ‚Äî SCRAPE FUNCTION # ========================================= def get_vencimentos(driver, wait, url="https://opcoes.net.br/opcoes/bovespa/ABEV3"): """ Accesses the provided URL and captures checkbox IDs and labels from the '#grade-vencimentos-dates' section. Returns two lists: labels (for display) and values (real IDs). """ print(f"üîó Acessando p√°gina: {url}") driver.get(url) try: wait.until(EC.presence_of_element_located((By.ID, "grade-vencimentos-dates"))) time.sleep(2) except TimeoutException: print("‚ö†Ô∏è Timeout ao carregar a p√°gina.") return [], [] container = driver.find_element(By.ID, "grade-vencimentos-dates") checkboxes = container.find_elements(By.TAG_NAME, "input") labels, values = [], [] for cb in checkboxes: label_id = cb.get_attribute("id") data_du = cb.get_attribute("data-du") if label_id: label_text = f"{label_id} - {data_du} d.u." labels.append(label_text) values.append(label_id) print(f"‚úÖ {len(labels)} vencimentos capturados.") print("labels ",labels) print("values ",values) return labels, values def ajuste(url2, tiker, val_mom, strike, bid, ask): """Calcula a f√≥rmula customizada.""" #print("verifk data ",url2, tiker) try: formula = (float(strike) - float(val_mom)) + (float(bid) - float(ask)) / (float(val_mom) + float(ask)) except Exception: formula = 0.0 return formula def armazem(df,name): """Salva dataframe em CSV e XLSX e faz download no Colab.""" df.to_csv(name+".csv", index=False) df.to_excel(name+".xlsx", index=False) files.download(name+".csv") files.download(name+".xlsx") return df def cadeiastring(i, datascall, datasput): """Extrai e formata strike, bid e ask de listas de dados call/put.""" try: strike = datascall[4] if len(datascall) > 26 else datascall[3] bid = datascall[11] or "0.0" ask = datasput[12] or "0.0" strike = strike.replace(".", "").replace(",", ".") bid = bid.replace(".", "").replace(",", ".") ask = ask.replace(".", "").replace(",", ".") return float(strike), float(bid), float(ask) except Exception: return 0.0, 0.0, 0.0 def extradados(table_container): """Extrai dados de uma tabela Selenium, com re-tentativas contra StaleElementReferenceException.""" retries = 3 for attempt in range(retries): try: rows = table_container.find_elements(By.TAG_NAME, "tr") table_data = [[cell.text for cell in row.find_elements(By.TAG_NAME, "td")] for row in rows] #print(table_data) return table_data except StaleElementReferenceException: print(f"Tentando recarregar tabela... ({attempt + 1}/{retries})") time.sleep(1) return [] # ---------------------------------------------------------- # FUN√á√ÉO PRINCIPAL: PRINP # ---------------------------------------------------------- def prinp(url2): """Extrai dados de um ativo espec√≠fico e retorna um resumo.""" print(f"\n==== Iniciando {url2} ====") url = f"https://opcoes.net.br/opcoes/bovespa/{url2}" driver.get(url) # Cota√ß√£o atual try: table2 = WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.ID, "divCotacaoAtual")) ) cotiz = table2.text.split() val_mom = float(cotiz[1].replace(".", "").replace(",", ".")) except Exception: val_mom = 0.0 #print(f"Valor atual: {val_mom}") # Espera tabela principal try: table_container = WebDriverWait(driver, 15).until( EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper")) ) except TimeoutException: print("‚ö†Ô∏è Tabela n√£o carregou.") return pd.DataFrame() table_data = extradados(table_container) if not table_data: return pd.DataFrame() resumo_list = [] #print("len tavla ",len(table_data)) for i in range(3, len(table_data), 2): if i + 1 >= len(table_data): break strike, bid, ask = cadeiastring(i, table_data[i], table_data[i + 1]) formula = ajuste(url2, table_data[i][0] if table_data[i] else "N/A", val_mom, strike, bid, ask) resumo_list.append({ "Ativo": url2, "Ticker": table_data[i][0] if table_data[i] else "N/A", "ValMom": val_mom, "Strike": strike, "Bid": bid, "Ask": ask, "Formula": formula }) df2 = pd.DataFrame(resumo_list) return df2 # ---------------------------------------------------------- # FUN√á√ÉO GET_SEL - APRIMORADA CONTRA STALE ELEMENTS # ---------------------------------------------------------- def get_sel(driver, string): all_dataframes = pd.DataFrame() if string=='todo': print("Iniciando coleta de op√ß√µes dispon√≠veis...") #all_dataframes = pd.DataFrame() retries = 3 for attempt in range(retries): try: select_element = WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.NAME, "IdAcao")) ) select = Select(select_element) all_options = select.options option_texts = [opt.text.strip() for opt in all_options if len(opt.text.strip()) > 1] print(f"Encontradas {len(option_texts)} op√ß√µes v√°lidas.") break except (StaleElementReferenceException, TimeoutException): print(f"Tentativa {attempt + 1}/{retries}: seletor recarregando...") time.sleep(2) else: print(" Selecionado um ativo.") current_time = datetime.now() print("Current Time:", current_time) driver.get(f"https://opcoes.net.br/opcoes/bovespa/{string}") WebDriverWait(driver, 15).until( EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper")) ) df_temp = prinp(string) all_dataframes = pd.concat([all_dataframes, df_temp], ignore_index=True) return all_dataframes for idx, option_text in enumerate(option_texts, start=1): print(f"\n[{idx}/{len(option_texts)}] Processando {option_text}...") for attempt in range(retries): try: current_time = datetime.now() print("Current Time:", current_time) driver.get(f"https://opcoes.net.br/opcoes/bovespa/{option_text}") WebDriverWait(driver, 15).until( EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper")) ) df_temp = prinp(option_text) if not df_temp.empty: all_dataframes = pd.concat([all_dataframes, df_temp], ignore_index=True) break except (StaleElementReferenceException, TimeoutException): print(f"‚ö†Ô∏è Tentativa {attempt + 1}/{retries} falhou em {option_text}, tentando novamente...") time.sleep(2) except Exception as e: print(f"‚ùå Erro inesperado com {option_text}: {e}") break print("\n‚úÖ Coleta finalizada com sucesso.") print(f"Total de registros obtidos: {len(all_dataframes)}") return all_dataframes # ---------------------------------------------------------- # EXECU√á√ÉO # ---------------------------------------------------------- url = "https://opcoes.net.br/opcoes/bovespa/AURE3" driver.get(url) final_df = get_sel(driver,"todo") user_threshold=-0.05 print("saida antes de filtro") display(final_df) armazem(final_df,"full") print("+++++++++++++++++++++++++++++++++++++++++++") if not final_df.empty and "Formula" in final_df.columns: # Filtro adicional baseado no valor m√≠nimo entre Bid e Ask try: #user_threshold = float(input("Digite o valor m√≠nimo permitido entre Bid e Ask (ex: 0.05): ")) final_df["MinBidAsk"] = final_df[["Bid", "Ask"]].min(axis=1) final_df = final_df[final_df["MinBidAsk"] >= user_threshold] print(f"\nüîé Filtradas {len(final_df)} linhas com Min(Bid, Ask) >= {user_threshold}") except Exception: print("‚ö†Ô∏è Nenhum filtro aplicado (erro ou valor inv√°lido).") # Ordena e exibe top 30 top30 = final_df.sort_values(by="Formula", ascending=False).head(30) display(top30) armazem(top30,"top30") driver.quit()
