

# =========================================
# STEP 1 ‚Äî INSTALL DEPENDENCIES
# =========================================
!apt-get update -qq
!apt-get install -qq chromium-chromedriver
!pip install -q selenium tabulate ipywidgets pillow pandas requests
# ============================================
# C√ìDIGO APRIMORADO (vers√£o completa, a partir de #c√≥digo 22)
# ============================================
# =========================================
# STEP 2 ‚Äî IMPORTS
# =========================================
%pip install -q selenium tabulate pandas
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import StaleElementReferenceException, TimeoutException
from PIL import Image
from google.colab import files, drive
import pandas as pd
import requests
import time
from tabulate import tabulate
from datetime import datetime
from IPython.display import display, clear_output
import ipywidgets as widgets



# ----------------------------------------------------------
# CONFIGURA√á√ÉO DO DRIVER (modo headless)
# ----------------------------------------------------------
chrome_options = Options()
chrome_options.add_argument("--headless")
chrome_options.add_argument("--no-sandbox")
chrome_options.add_argument("--disable-dev-shm-usage")
chrome_options.add_argument("--window-size=1920,1080")

driver = webdriver.Chrome(options=chrome_options)
wait = WebDriverWait(driver, 15)
driver.set_window_size(1920, 1080)
#return driver, wait

# ----------------------------------------------------------
# FUN√á√ïES AUXILIARES
# ----------------------------------------------------------
# =========================================
# STEP 4 ‚Äî SCRAPE FUNCTION
# =========================================
def get_vencimentos(driver, url="https://opcoes.net.br/opcoes/bovespa/AMBP3"):
    """Opens the page and returns all available vencimento labels + IDs."""
    driver.get(url)
    time.sleep(3)
    driver.execute_script("window.scrollBy(200000, 0);")
    try:
        # ‚úÖ FIX: use correct ID listavencimentos
        WebDriverWait(driver, 15).until(
            EC.presence_of_element_located((By.ID, "listavencimentos"))
        )
        time.sleep(1)
        checkboxes = driver.find_elements(By.CSS_SELECTOR, "#listavencimentos input[type='checkbox']")
        vencimentos = []
        for cb in checkboxes:
            try:
                label = cb.find_element(By.XPATH, "..").text.strip()
            except:
                label = cb.get_attribute("id")
            vencimentos.append({"id": cb.get_attribute("id"), "label": label})
        print(f"‚úÖ Detected {len(vencimentos)} vencimentos.")
        return vencimentos
    except Exception as e:
        print("‚ùå Error detecting checkboxes:", e)
        return []

# =========================================
# Function: Clear and set vencimentos
# =========================================
def set_vencimentos(driver, ativo, selected_ids):
    """Opens user-defined ativo page, clears old selections, sets new ones, waits, and screenshots."""
    url = f"https://opcoes.net.br/opcoes/bovespa/{ativo.upper()}"
    print(f"üåê Opening {url}")
    driver.get(url)
    time.sleep(3)
    driver.execute_script("window.scrollBy(200000, 0);")

    # Wait until vencimentos load
    try:
        WebDriverWait(driver, 15).until(
            EC.presence_of_element_located((By.ID, "listavencimentos"))
        )
        checkboxes = driver.find_elements(By.CSS_SELECTOR, "#listavencimentos input[type='checkbox']")
        cleared = 0
        for cb in checkboxes:
            if cb.is_selected():
                driver.execute_script("arguments[0].click();", cb)
                cleared += 1
        print(f"‚úÖ Cleared {cleared} previous checkboxes.")

        # Set selected vencimentos
        for cb in checkboxes:
            cb_id = cb.get_attribute("id")
            if cb_id in selected_ids:
                driver.execute_script("arguments[0].click();", cb)
                print(f"‚úÖ Selected {cb_id}")

        print("‚è≥ Waiting 3 seconds for page update...")
        time.sleep(3)

        screenshot_path = f"/content/vencimentos.png"
        driver.save_screenshot(screenshot_path)
        print(f"üì∏ Screenshot saved as {screenshot_path}")

    except Exception as e:
        print("‚ùå Error setting vencimentos:", e)

# =========================================
# Step 1 ‚Äî Get vencimentos from initial page
# =========================================
#vencimentos = get_vencimentos(driver)




def ajuste(url2, tiker, val_mom, strike, bid, ask):
    """Calcula a f√≥rmula customizada."""
    #print("verifk data     ",url2, tiker)
    try:
        formula = (float(strike) - float(val_mom)) + (float(bid) - float(ask)) / (float(val_mom) + float(ask))
    except Exception:
        formula = 0.0
    return formula


def armazem(df,name):
    """Salva dataframe em CSV e XLSX e faz download no Colab."""
    df.to_csv(name+".csv", index=False)
    df.to_excel(name+".xlsx", index=False)
    files.download(name+".csv")
    files.download(name+".xlsx")
    return df


def cadeiastring(i, datascall, datasput):
    """Extrai e formata strike, bid e ask de listas de dados call/put."""
    try:
        strike = datascall[4] if len(datascall) > 26 else datascall[3]
        bid = datascall[11] or "0.0"
        ask = datasput[12] or "0.0"
        strike = strike.replace(".", "").replace(",", ".")
        bid = bid.replace(".", "").replace(",", ".")
        ask = ask.replace(".", "").replace(",", ".")
        return float(strike), float(bid), float(ask)
    except Exception:
        return 0.0, 0.0, 0.0


def extradados(table_container):
    """Extrai dados de uma tabela Selenium, com re-tentativas contra StaleElementReferenceException."""
    retries = 3
    for attempt in range(retries):
        try:
            rows = table_container.find_elements(By.TAG_NAME, "tr")
            table_data = [[cell.text for cell in row.find_elements(By.TAG_NAME, "td")] for row in rows]
            #print(table_data)
            return table_data
        except StaleElementReferenceException:
            print(f"Tentando recarregar tabela... ({attempt + 1}/{retries})")
            time.sleep(1)
    return []


# ----------------------------------------------------------
# FUN√á√ÉO PRINCIPAL: PRINP
# ----------------------------------------------------------
def prinp(url2):
    """Extrai dados de um ativo espec√≠fico e retorna um resumo."""
    print(f"\n==== Iniciando {url2} ====")
    url = f"https://opcoes.net.br/opcoes/bovespa/{url2}"
    driver.get(url)

    # Cota√ß√£o atual
    try:
        table2 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "divCotacaoAtual"))
        )
        cotiz = table2.text.split()
        val_mom = float(cotiz[1].replace(".", "").replace(",", "."))
    except Exception:
        val_mom = 0.0

    #print(f"Valor atual: {val_mom}")

    # Espera tabela principal
    try:
        table_container = WebDriverWait(driver, 15).until(
            EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper"))
        )
    except TimeoutException:
        print("‚ö†Ô∏è Tabela n√£o carregou.")
        return pd.DataFrame()

    table_data = extradados(table_container)
    if not table_data:
        return pd.DataFrame()

    resumo_list = []
    #print("len tavla  ",len(table_data))
    for i in range(3, len(table_data), 2):
        if i + 1 >= len(table_data):
            break
        strike, bid, ask = cadeiastring(i, table_data[i], table_data[i + 1])
        formula = ajuste(url2, table_data[i][0] if table_data[i] else "N/A", val_mom, strike, bid, ask)
        resumo_list.append({
            "Ativo": url2,
            "Ticker": table_data[i][0] if table_data[i] else "N/A",
            "ValMom": val_mom,
            "Strike": strike,
            "Bid": bid,
            "Ask": ask,
            "Formula": formula
        })

    df2 = pd.DataFrame(resumo_list)
    return df2


# ----------------------------------------------------------
# FUN√á√ÉO GET_SEL - APRIMORADA CONTRA STALE ELEMENTS
# ----------------------------------------------------------
def get_sel(driver, string):
    all_dataframes = pd.DataFrame()
    if string=='todo':
      print("Iniciando coleta de op√ß√µes dispon√≠veis...")

      #all_dataframes = pd.DataFrame()
      retries = 3

      for attempt in range(retries):
         try:
            select_element = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.NAME, "IdAcao"))
            )
            select = Select(select_element)
            all_options = select.options
            option_texts = [opt.text.strip() for opt in all_options if len(opt.text.strip()) > 1]
            print(f"Encontradas {len(option_texts)} op√ß√µes v√°lidas.")
            break
         except (StaleElementReferenceException, TimeoutException):
              print(f"Tentativa {attempt + 1}/{retries}: seletor recarregando...")
              time.sleep(2)
    else:
        print(" Selecionado um ativo.")
        current_time = datetime.now()
        print("Current Time:", current_time)
        driver.get(f"https://opcoes.net.br/opcoes/bovespa/{string}")
        WebDriverWait(driver, 15).until(
                    EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper"))
                )
        df_temp = prinp(string)
        all_dataframes = pd.concat([all_dataframes, df_temp], ignore_index=True)
        return all_dataframes

    for idx, option_text in enumerate(option_texts, start=1):
        print(f"\n[{idx}/{len(option_texts)}] Processando {option_text}...")
        for attempt in range(retries):
            try:
                current_time = datetime.now()
                print("Current Time:", current_time)
                driver.get(f"https://opcoes.net.br/opcoes/bovespa/{option_text}")
                WebDriverWait(driver, 15).until(
                    EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper"))
                )
                df_temp = prinp(option_text)
                if not df_temp.empty:
                    all_dataframes = pd.concat([all_dataframes, df_temp], ignore_index=True)
                break
            except (StaleElementReferenceException, TimeoutException):
                print(f"‚ö†Ô∏è Tentativa {attempt + 1}/{retries} falhou em {option_text}, tentando novamente...")
                time.sleep(2)
            except Exception as e:
                print(f"‚ùå Erro inesperado com {option_text}: {e}")
                break
  

    print("\n‚úÖ Coleta finalizada com sucesso.")
    print(f"Total de registros obtidos: {len(all_dataframes)}")
    return all_dataframes


# ----------------------------------------------------------
# EXECU√á√ÉO
# ----------------------------------------------------------
url = "https://opcoes.net.br/opcoes/bovespa/AURE3"
driver.get(url)
final_df = get_sel(driver,"A1MD34")
user_threshold=-0.05
print("saida antes de filtro")
display(final_df)
armazem(final_df,"full")
print("+++++++++++++++++++++++++++++++++++++++++++")
if not final_df.empty and "Formula" in final_df.columns:
    # Filtro adicional baseado no valor m√≠nimo entre Bid e Ask
    try:
        #user_threshold = float(input("Digite o valor m√≠nimo permitido entre Bid e Ask (ex: 0.05): "))
        final_df["MinBidAsk"] = final_df[["Bid", "Ask"]].min(axis=1)
        final_df = final_df[final_df["MinBidAsk"] >= user_threshold]
        print(f"\nüîé Filtradas {len(final_df)} linhas com Min(Bid, Ask) >= {user_threshold}")
    except Exception:
        print("‚ö†Ô∏è Nenhum filtro aplicado (erro ou valor inv√°lido).")

    # Ordena e exibe top 30
    top30 = final_df.sort_values(by="Formula", ascending=False).head(30)
    display(top30)
    armazem(top30,"top30")









driver.quit()

