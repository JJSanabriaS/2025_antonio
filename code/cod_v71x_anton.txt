# =========================================
# STEP 1 ‚Äî INSTALL DEPENDENCIES
# =========================================
!apt-get update -qq
!apt-get install -qq chromium-chromedriver
!pip install -q selenium tabulate ipywidgets pillow pandas requests
# ============================================
# C√ìDIGO APRIMORADO (vers√£o completa, a partir de #c√≥digo 22)
# ============================================
# =========================================
# STEP 2 ‚Äî IMPORTS
# =========================================
%pip install -q selenium tabulate pandas
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import StaleElementReferenceException, TimeoutException
from PIL import Image
from google.colab import files, drive
import pandas as pd
import requests
import time
from tabulate import tabulate
from datetime import datetime
from IPython.display import display, clear_output
import ipywidgets as widgets



# ----------------------------------------------------------
# CONFIGURA√á√ÉO DO DRIVER (modo headless)
# ----------------------------------------------------------
chrome_options = Options()
chrome_options.add_argument("--headless")
chrome_options.add_argument("--no-sandbox")
chrome_options.add_argument("--disable-dev-shm-usage")
chrome_options.add_argument("--window-size=1920,1080")

driver = webdriver.Chrome(options=chrome_options)
wait = WebDriverWait(driver, timeout=10)
driver.set_window_size(1920, 1080)  # Full HD size


# ----------------------------------------------------------
# FUN√á√ïES AUXILIARES
# ----------------------------------------------------------

def droplistven():
    url = "https://opcoes.net.br/opcoes/bovespa/AMBP3"
    driver.get(url)
    vencimentos = driver.find_element(By.ID, "grade-vencimentos-dates")
    # Use WebDriverWait to wait for the checkbox to be clickable
    # Changed the locator to be more specific if possible, targeting the checkbox within the vencimentos element
    checkbox = wait.until(EC.presence_of_element_located((By.XPATH, "//div[@id='grade-vencimentos-dates']//input[@type='checkbox']")))
    #print("grade tipo")
    #print(vencimentos.text)
    ids = driver.find_elements(By.TAG_NAME,"input")
    vencimentos=[]
    datas=[]
    data_du=[]
    mix=[]
    for ii in ids:
        #print ii.tag_name
        #print (ii.get_attribute('id'))    # id name as string
        datas.append(ii.get_attribute('id'))
        data_du.append(ii.get_attribute('data-du'))
        #print("label    ",ii.get_attribute('label'))
        #print("value   ",ii.get_attribute('value'))
        #print("data-du   ",ii.get_attribute('data-du'))
        vencimentos.append(ii.get_attribute('selected'))
        mix.append(str(ii.get_attribute('id'))+"  - "+str(ii.get_attribute('data-du'))+" "+" d.u.")
        #print(str(ii.get_attribute('id'))+"  - "+str(ii.get_attribute('data-du'))+" "+" d.u.")


        #if id_val :
        #    datas.append(id_val)
    #print(f"‚úÖ Found {len(datas)} vencimentos.")
    box=len(datas)-5
    #print(datas[0:3])
    #print(vencimentos[0:3])
   # print("labels  ", datas[3:box])
    vendatas=datas[3:box]
    venlabels=mix[3:box]
    #print(datas)
    #print (data_du[3:box]+"d.u.")
    return venlabels,vendatas


def ajuste(url2, tiker, val_mom, strike, bid, ask):
    """Calcula a f√≥rmula customizada."""
    #print("verifk data     ",url2, tiker)
    try:
        formula = (float(strike) - float(val_mom)) + (float(bid) - float(ask)) / (float(val_mom) + float(ask))
    except Exception:
        formula = 0.0
    return formula


def armazem(df,name):
    """Salva dataframe em CSV e XLSX e faz download no Colab."""
    df.to_csv(name+".csv", index=False)
    df.to_excel(name+".xlsx", index=False)
    files.download(name+".csv")
    files.download(name+".xlsx")
    return df


def cadeiastring(i, datascall, datasput):
    """Extrai e formata strike, bid e ask de listas de dados call/put."""
    try:
        strike = datascall[4] if len(datascall) > 26 else datascall[3]
        bid = datascall[11] or "0.0"
        ask = datasput[12] or "0.0"
        strike = strike.replace(".", "").replace(",", ".")
        bid = bid.replace(".", "").replace(",", ".")
        ask = ask.replace(".", "").replace(",", ".")
        return float(strike), float(bid), float(ask)
    except Exception:
        return 0.0, 0.0, 0.0


def extradados(table_container):
    """Extrai dados de uma tabela Selenium, com re-tentativas contra StaleElementReferenceException."""
    retries = 3
    for attempt in range(retries):
        try:
            rows = table_container.find_elements(By.TAG_NAME, "tr")
            table_data = [[cell.text for cell in row.find_elements(By.TAG_NAME, "td")] for row in rows]
            #print(table_data)
            return table_data
        except StaleElementReferenceException:
            print(f"Tentando recarregar tabela... ({attempt + 1}/{retries})")
            time.sleep(1)
    return []


# ----------------------------------------------------------
# FUN√á√ÉO PRINCIPAL: PRINP
# ----------------------------------------------------------
def prinp(url2):
    """Extrai dados de um ativo espec√≠fico e retorna um resumo."""
    print(f"\n==== Iniciando {url2} ====")
    url = f"https://opcoes.net.br/opcoes/bovespa/{url2}"
    driver.get(url)

    # Cota√ß√£o atual
    try:
        table2 = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "divCotacaoAtual"))
        )
        cotiz = table2.text.split()
        val_mom = float(cotiz[1].replace(".", "").replace(",", "."))
    except Exception:
        val_mom = 0.0

    #print(f"Valor atual: {val_mom}")

    # Espera tabela principal
    try:
        table_container = WebDriverWait(driver, 15).until(
            EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper"))
        )
    except TimeoutException:
        print("‚ö†Ô∏è Tabela n√£o carregou.")
        return pd.DataFrame()

    table_data = extradados(table_container)
    if not table_data:
        return pd.DataFrame()

    resumo_list = []
    #print("len tavla  ",len(table_data))
    for i in range(3, len(table_data), 2):
        if i + 1 >= len(table_data):
            break
        strike, bid, ask = cadeiastring(i, table_data[i], table_data[i + 1])
        formula = ajuste(url2, table_data[i][0] if table_data[i] else "N/A", val_mom, strike, bid, ask)
        resumo_list.append({
            "Ativo": url2,
            "Ticker": table_data[i][0] if table_data[i] else "N/A",
            "ValMom": val_mom,
            "Strike": strike,
            "Bid": bid,
            "Ask": ask,
            "Formula": formula
        })

    df2 = pd.DataFrame(resumo_list)
    return df2


# ----------------------------------------------------------
# FUN√á√ÉO GET_SEL - APRIMORADA CONTRA STALE ELEMENTS
# ----------------------------------------------------------
def get_sel(driver, string):
    all_dataframes = pd.DataFrame()
    if string=='todo':
      print("Iniciando coleta de op√ß√µes dispon√≠veis...")

      #all_dataframes = pd.DataFrame()
      retries = 3

      for attempt in range(retries):
         try:
            select_element = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.NAME, "IdAcao"))
            )
            select = Select(select_element)
            all_options = select.options
            option_texts = [opt.text.strip() for opt in all_options if len(opt.text.strip()) > 1]
            print(f"Encontradas {len(option_texts)} op√ß√µes v√°lidas.")
            break
         except (StaleElementReferenceException, TimeoutException):
              print(f"Tentativa {attempt + 1}/{retries}: seletor recarregando...")
              time.sleep(2)
    else:
        print(" Selecionado um ativo.")
        current_time = datetime.now()
        print("Current Time:", current_time)
        driver.get(f"https://opcoes.net.br/opcoes/bovespa/{string}")
        WebDriverWait(driver, 15).until(
                    EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper"))
                )
        df_temp = prinp(string)
        all_dataframes = pd.concat([all_dataframes, df_temp], ignore_index=True)
        return all_dataframes

    for idx, option_text in enumerate(option_texts, start=1):
        print(f"\n[{idx}/{len(option_texts)}] Processando {option_text}...")
        for attempt in range(retries):
            try:
                current_time = datetime.now()
                print("Current Time:", current_time)
                driver.get(f"https://opcoes.net.br/opcoes/bovespa/{option_text}")
                WebDriverWait(driver, 15).until(
                    EC.presence_of_element_located((By.ID, "tblListaOpc_wrapper"))
                )
                df_temp = prinp(option_text)
                if not df_temp.empty:
                    all_dataframes = pd.concat([all_dataframes, df_temp], ignore_index=True)
                break
            except (StaleElementReferenceException, TimeoutException):
                print(f"‚ö†Ô∏è Tentativa {attempt + 1}/{retries} falhou em {option_text}, tentando novamente...")
                time.sleep(2)
            except Exception as e:
                print(f"‚ùå Erro inesperado com {option_text}: {e}")
                break
  

    print("\n‚úÖ Coleta finalizada com sucesso.")
    print(f"Total de registros obtidos: {len(all_dataframes)}")
    return all_dataframes


# ----------------------------------------------------------
# EXECU√á√ÉO
# ----------------------------------------------------------
url = "https://opcoes.net.br/opcoes/bovespa/AURE3"
driver.get(url)
final_df = get_sel(driver,"todo")
user_threshold=-0.05
print("saida antes de filtro")
display(final_df)
armazem(final_df,"full")
print("+++++++++++++++++++++++++++++++++++++++++++")
if not final_df.empty and "Formula" in final_df.columns:
    # Filtro adicional baseado no valor m√≠nimo entre Bid e Ask
    try:
        #user_threshold = float(input("Digite o valor m√≠nimo permitido entre Bid e Ask (ex: 0.05): "))
        final_df["MinBidAsk"] = final_df[["Bid", "Ask"]].min(axis=1)
        final_df = final_df[final_df["MinBidAsk"] >= user_threshold]
        print(f"\nüîé Filtradas {len(final_df)} linhas com Min(Bid, Ask) >= {user_threshold}")
    except Exception:
        print("‚ö†Ô∏è Nenhum filtro aplicado (erro ou valor inv√°lido).")

    # Ordena e exibe top 30
    top30 = final_df.sort_values(by="Formula", ascending=False).head(30)
    display(top30)
    armazem(top30,"top30")









driver.quit()

